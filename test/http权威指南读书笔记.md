---
categories:
- 读书笔记
date: 2022-12-12 07:34:21
password: null
sticky: 100
tags:
- http
- uri
- web
- url
- cookie
title: http权威指南读书笔记
---

> 

<!--more-->

# 第1章HTTP概述 

## 1.1 HTTP——因特网的多媒体信使 

## 1.2 Web客户端和服务器 

## 1.3资源 

### 1.3.1媒体类型 

MIME (multipurpose internet mail extensions)

### 1.3.2 URI 

URI uniform resource identifier

### 1.3.3 URL 

uniform resource link

### 1.3.4 URN 

uniform resource name

## 1.4事务 

一个HTTP事务由一条(从客户端发往服务器的)请求命令和一个(从服务器发回客户端的)响应结果组成。这种通信是通过名为HTTP报文(HTTP message)的格式化数据块进行的

### 1.4.1方法 

### 1.4.2状态码 

### 1.4.3 Web页面中可以包含多个对象 

## 1.5报文 

## 1.6连接 

### 1.6.1 TCPIP 

### 1.6.2连接、IP地址及端口号 

http 默认 port 80

### 1.6.3使用Telnet实例 

## 1.7协议版本 

## 1.8 Web的结构组件 

### 1.8.1代理 

### 1.8.2缓存 

### 1.8.3网关 

### 1.8.4隧道 

### 1.8.5 Agent代理 

## 1.9起始部分的结束语 

## 1.10更多信息 

### 1.10.1 HTTP协议信息 

### 1.10.2历史透视 

### 1.10.3其他万维网信息 

# 第2章URL与资源 

## 2.1浏览因特网资源 

http://www.joes-hardware.com/seasonal/index-fall.html

url 方案 + 服务器位置 + 资源路径

## 2.2 URL的语法 

### 2.2.1方案——使用什么协议 

### 2.2.2主机与端口 

### 2.2.3用户名和密码 

### 2.2.4路径 

### 2.2.5参数 

 ftp://prep.ai.mit.edu/pub/gnu;type=d

### 2.2.6查询字符串 

http://www.joes-hardware.com/inventory-check.cgi?item=12731&color=blue

?属性=属性&属性=属性

### 2.2.7片段 

http://www.joes-hardware.com/tools.html#drills

\#标签

客户端不能将片段传给服务器, 浏览器会根据片段显示感兴趣的资源

## 2.3 URL快捷方式 

### 2.3.1相对URL 

![截屏2022-12-12 08.40.20](https://tva1.sinaimg.cn/large/008vxvgGly1h90qdsgbi4j30wo0tmwhy.jpg)

### 2.3.2自动扩展URL 

## 2.4各种令人头疼的字符 

### 2.4.1 URL字符集 

### 2.4.2编码机制 

%hex_1 hex_2 表示 ascii 码

### 2.4.3字符限制 

### 2.4.4另外一点说明 

## 2.5方案的世界 

mailto:joe@joes-hardware.com
ftp://anonymous:joe%40joeshardware.com@prep.ai.mit.edu:21/pub/gnu/

file:///Users/akunda/Downloads/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%AD%E6%96%87%E7%89%88ocr%EF%BC%89.pdf

## 2.6未来展望 

## 2.7更多信息 

# 第3章 HTTP报文 

## 3.1报文流 

### 3.1.1报文流入源端服务器 

### 3.1.2报文向下游流动 

## 3.2报文的组成部分 

起始行和首部是 ascii 文本

### 3.2.1报文的语法 

### 3.2.2起始行 

### 3.2.3首部 

### 3.2.4实体的主体部分 

#### 3.2.5版本0.9的报文 

## 3.3方法 

### 3.3.1 安全方法 

get head, 使用这类 http 请求不会在服务器上产生什么结果

### 3.3.2 GET 

### 3.3.3 HEAD

服务器开发者必须确保返回的首部与 GET 请求所返回的首部完全相同。遵循 HTTP/1.1 规范，就必须实现 HEAD 方法。

### 3.3.4 PUT 

将请求的主体部分存储在服务器上, 具有幂等性

PUT 方法的语义就是让服务器用请求的主体部分来创建 1 个由所请求的 URL 命名的新文档，或者，如果那个 URL 已经存在的话，就用这个主体来替代它。

### 3.3.5 POST 

向服务器发送需要处理的数据

通常用啦支持表单(form)

### 3.3.6 TRACE 

### 3.3.7 OPTIONS 

### 3.3.8 DELETE 

### 3.3.9扩展方法 

## 3.4状态码 

![截屏2022-12-12 16.39.11](https://tva1.sinaimg.cn/large/008vxvgGly1h9147yyfyhj30ts0hydil.jpg)

![截屏2022-12-12 16.39.28](https://tva1.sinaimg.cn/large/008vxvgGly1h91489y6kpj30te13y45b.jpg)

![截屏2022-12-12 16.39.39](https://tva1.sinaimg.cn/large/008vxvgGly1h9148igds3j30te0x2tei.jpg)

## 3.5首部 

### 3.5.1通用首部 

### 3.5.2请求首部 

### 3.5.3响应首部 

### 3.5.4实体首部 

## 3.6更多信息 

# 第4章 连接管理 

## 4.1 TCP连接 

### 4.1.1 TCP的可靠数据管道 

### 4.1.2 TCP流是分段的、由IP分组传送 

### 4.1.3保持TCP连接的正确运行 

### 4.1.4用TCP套接字编程 

## 4.2对TCP性能的考虑 

### 4.2.1 HTTP事务的时延 

### 4.2.2 性能聚焦区域 

TCP 连接建立握手

TCP 慢启动拥塞控制

 数据聚集的 Nagle 算法

 用于捎带确认的 TCP 延迟确认算法

TIME_WAIT 时延和端口耗尽

### 4.2.3 TCP连接的握手时延 

tcp 三次握手

### 4.2.4延迟确认 

延迟确认算法会在一个特定的窗口时间（通常是100~ 200毫 秒）内将输出确认存放在**缓冲区**中，以寻找能够捎带它的输出数据分组。如果在那 个时间段内没有输出数据分组，就将确认信息放在单独的分组中传送。

一问一答的模式会被这种算法限制速度, 可以禁用

### 4.2.5 TCP慢启动 

可以使用持久连接

### 4.2.6 Nagle算法与TCP_NODELAY 

Nagle 算法（根据其发明者 John Nagle 命名）试图在发送一个分组之前，将大量 TCP 数据绑定在一起，以提高网络效率。RFC 896 “TP/TCP 互连网络中的拥塞控 制”对此算法进行了描述。它鼓励发送全尺寸的tcp 段 (LAN 1500 bytes)

用 TCP_NODELAY 禁用 nagle 算法

### 4.2.7 TIME_WAIT累积与端口耗尽 

2MSL 

## 4.3 HTTP连接的处理 

### 4.3.1常被误解的Connection首部 

逐跳首部, 跳完删除

HTTP 应用程序收到一条带有 Connection 首部的报文时，接收端会解析发送端 请求的所有选项，并将其应用。
然后会在将此报文转发给下一跳地址之前，**删除 Connection 首部以及 Connection 中列出的所有首部。**

### 4.3.2串行事务处理时延 

## 4.4并行连接 

### 4.4.1并行连接可能会提高页面的加载速度 

### 4.4.2并行连接不一定更快 

可能原因是因为带宽不足

### 4.4.3并行连接可能让人“感觉”更快一些 

## 4.5持久连接 

减少开销: 慢启动, 连接建立

### 4.5.1 持久以及并行连接 

#### 4.5.2 HTTP/1.0+ keep-alive连接 

### 4.5.3 Keep-Alive操作 

### 4.5.4 Keep-Alive选项 

### 4.5.5 Keep-Alive连接的限制和规则 

### 4.5.6 Keep-Alive和哑代理 

盲中继: 不理解 connection 首部的代理

![截屏2022-12-13 04.53.16](https://tva1.sinaimg.cn/large/008vxvgGly1h96wg3r99pj30wm0g00uh.jpg)

因此代理必须删除 connection 中的首部

### 4.5.7插入Proxy-Connection 

在网景的变通做法是，浏览器会向代理发送非标准的 Proxy-Connection 扩展首部，而不是官方支持的著名的 Connection 首部。如果代理是盲中继，它会将无意义的 Proxy-Connection 首部转发给 Web 服务器，服务器会忽略此首部，不会带来任何问题。
但如果代理是个聪明的代理（能够理解持久连接的握手动作)，就用一个 Connection 首部取代无意义的 Proxy-Connection 首部，然后将其发送给服务器，以收到预期的效果。

#### 4.5.8 HTTP/ 1.1持久连接 

默认激活

### 4.5.9持久连接的限制和规则 

"如果客户端不想在连接上发送其他请求了，就应该在最后一条请求中发送一个 Conneetion: close 请求首部。

HTTP/1.1 的代理必须能够分别管理与客户端和服务器的持久连接——每个持久 连接都只适用于**一跳传输**。

## 4.6管道化连接 

## 4.7关闭连接的奥秘 

### 4.7.1“任意”解除连接 

### 4.7.2 Content-Length及截尾操作 

任何 http 响应都应该有明确的 content-length 首部, 用来预防连接的突然关闭

### 4.7.3连接关闭容限、重试以及幂等性 

客户端不应该对非幂等请求进行管道连接(post)

### 4.7.4正常关闭连接 

半关闭: 单独关闭输入或者输出通道

关闭输出信道是安全的, 关闭输入信道是危险的

比如你已经在一条持久连接上发送了10 条管道式请求了，响应也已经收到了，正在操作系统的缓冲区中存着呢（但应用程序还未将其读走)。
现在，假设你发送了 第11条请求，但服务器认为你使用这条连接的时间已经够长了，决定将其关闭。那么你的第11 条请求就会被发送到一条已关闭的连接上去，并会向你回送一条重置信 息。**这个重置信息会清空你的输人缓冲区。**

但不幸的是，无法确保对等实体会实现半关闭，或对其进行检查。因此，想要正常关闭连接的应用程序应该**先半关闭其输出信道，然后周期性地检查其输入信道的状态**（查找数据，或流的末尾)。如果在一定的时间区间内对端没有关闭输人信道，应用程序可以强制关闭连接，以节省资源。

## 4.8更多信息 

### 4.8.1 HTTP连接 

### 4.8.2 HTTP性能问题 

### 4.8.3 TCPIP 

# 第5章Web服务器 

## 5.1各种形状和尺寸的Web服务器 

### 5.1.1 Web服务器的实现 

### 5.1.2通用软件Web服务器 

### 5.1.3 Web服务器设备 

### 5.1.4嵌入式Web服务器 

## 5.2最小的Perl Web服务器 

## 5.3实际的Web服务器会做些什么 

## 5.4第一步——接受客户端连接 

### 5.4.1处理新连接 

### 5.4.2客户端主机名识别 

反向 DNS, 将客户端 ip 转换成主机名

### 5.4.3通过ident确定客户端用户 

如果客户端支持 ident 协议, 就会在 113 port 监听请求, 服务端从这里请求用户名

## 5.5第二步——接收请求报文 

### 5.5.1报文的内部表示法 

### 5.5.2连接的输入／输出处理结构 

## 5.6第三步——处理请求 

## 5.7第四步——对资源的映射及访问 

### 5.7.1 docroot 

Web 服务器支持各种不同类型的资源映射，但最简单的资源映射形式就是用请求 URI作为名字来访问 Web服务器文件系统中的文件。
通常，web 服务器的文件系统中会有一个特殊的文件夹专门用于存放 Web 内容。这个文件夹被称为文档的根目录（document root，或 docroot)。Web 服务器从请求报文中获取 URI，并将其附加在文档根目录的后面。

### 5.7.2目录列表 

web 服务器对应目录 url 的请求时

1. 返回错误
2. 返回索引文件 index.html
3. 扫描目录, 返回包含目录内容的文件

### 5.7.3动态内容资源的映射 

cgi common gateway interface

### 5.7.4服务器端包含项 

SSI server side includes

### 5.7.5访问控制 

## 5.8第五步——构建响应 

### 5.8.1响应实体 

### 5.8.2 MIME类型 

### 5.8.3重定向 

- 永久删除资源 301
- 临时删除资源 303, 307
- url 增强
- 负载均衡
- 服务器关联
- 规范目录名称 在目录名后加斜线

## 5.9第六步——发送响应 

## 5.10第七步——记录日志 

## 5.11更多信息 

# 第6章 代理 

## 6.1 Web的中间实体 

### 6.1.1私有和共享代理 

### 6.1.2代理与网关的对比 

代理两端使用同一种协议

网关将不同的协议连接起来

## 6.2为什么使用代理 

- 防火墙
- web 缓存
- 反向代理
  - 正向代理: 代理属于客户端的一部分
  - 反向代理: 代理为服务器的一部分
- 内容路由器
- 转码器
- 匿名

## 6.3代理会去往何处 

### 6.3.1代理服务器的部署 

### 6.3.2代理的层次结构 

### 6.3.3代理是如何获取流量的 

- 修改客户端
- 修改网络, 拦截代理
- 修改 dns
- 修改 web 服务器

## 6.4客户端的代理设置 

PAC proxy auto configuration

WPAD web proxy autodiscovery protocol

### 6.4.1客户端的代理配置：手工配置 

### 6.4.2客户端代理配置：PAC文件 

FindProxyForURL(url, host)

返回:

- direct 直接连接
- proxy host:port 使用指定代理
- socks host:port 使用指定 socks 服务器(使用 socks(socket secure) 协议的服务器)
  Bill希望通过互联网与Jane沟通，但他们的网络之间存在一个[防火墙](https://zh.m.wikipedia.org/wiki/防火墙)，Bill不能直接与Jane沟通。所以，Bill连接到他的网络上的SOCKS代理，告知它他想要与Jane建立连接；SOCKS代理打开一个能穿过防火墙的连接，并促进Bill和Jane之间的通信。

### 6.4.3客户端代理配置：WPAD 

## 6.5与代理请求有关的一些棘手问题 

### 6.5.1代理URI与服务器URI的不同 

(1)没有设置客户端使用代理时，它会发送部分 URI（参见图 6-15a)。 

(2）设置客户端使用代理时，它会发送完整 URI（参见图 6-15b)。

### 6.5.2与虚拟主机一样的问题 

显式的代理要求在请求报文中使用完整 URI 来解决这个问题

虚拟主机 Web 服务器要求使用 Host 首部来承载主机和端口信息。

### 6.5.3拦截代理会收到部分URI 

### 6.5.4代理既可以处理代理请求，也可以处理服务器请求 

- 如果提供的是完整 URI，代理就应该使用这个完整 URI。

-  如果提供的是部分 URI，而且有 Host 首部，就应该用 Host 首部来确定原始服 务器的名字和端口号。 
- 如果提供的是部分 URI,而且没有Host 首部,就要用其他方法来确定原始服务器： 
  - 如果代理是代表原始服务器的替代物，可以用真实服务器的地址和端口号来 配置代理：
  - 如果流最被拦截了，而且拦截者也可以提供原始的IP 地址和端口，代理就可 以使用拦截技术提供的IP 地址和端口号（参见第20章
  - 如果所有方法都失败了，代理没有足够的信息来确定原始服务器，就必须返 回一条错误报文（通常是建议用户升级到支持 Host 首部的现代浏览器)。

### 6.5.5转发过程中对URI的修改 

### 6.5.6 URI的客户端自动扩展和主机名解析 

但是，如果没有找到主机，很多浏览器都会尝试者提供某种主机名自动“扩展”机制，以防用户输入的是主机“简短”的缩写形式）。

- 很多浏览器会尝试着加入前缀 www.和后缀.com
- 有些浏览器甚至会将未解析出来的 URI 传递给第三方站点，这个站点会尝试着 校正拼写错误，并给出一些用户可能希望访问的 URI 建议。 
- 而且，大多数系统中的 DNS配置允许用户只输入主机名的前缀，然后 DNS 会自 动搜索域名。如果用户位于域名 oreilly.com 的范围之内，并输人了主机名 host7， DNS会自动尝试将其与 host7.oreilly.com 进行匹配。这并不是完整有效的主机名。

### 6.5.7没有代理时URI的解析 

客户端查找有效主机名

### 6.5.8有显式代理时URI的解析 

不扩展直接发给代理

### 6.5.9有拦截代理时URI的解析 

客户端查找有效的主机名

在第(4a) 步中，客户端已经成功解析了主机名，并有了一张IP 地址列表。有些 IP 地址可能已经停用了，所以，通常客户端会**尝试着连接每个 IP 地址**，直到成 功为止。
但对拦截代理来说，第一次连接请求就会被代理服务器拦截成功，不会 连接到原始服务器上去。客户端认为它在与 Web 服务器进行成功的对话，但那 个 Web 服务器可能甚至都不处于活跃状态。 当代理最终准备好与真正的原始服务器进行交互时〔第（5b）步]，代理可能会发 现那个 IP 地址实际指向的是一个已停用的服务器。为了提供与浏览器相同级别 的容错机制，**代理可以通过解析 Host 首部的主机名，也可以通过对IP 地址的反向 DNS 查找来尝试其他IP 地址。**將浏览器配置为使用显式代理时，它们会依赖 代理的容错机制，所以对拦截和显式的代理实现来说，在 DNS解析到已停用服 务器时，提供容错机制是很重要的。

## 6.6追踪报文 

### 6.6.1 via首部 

### 6.6.2 TRACE方法 

## 6.7代理认证 

407

## 6.8代理的互操作性 

### 6.8.1处理代理不支持的首部和方法 

### 6.8.2 OPTIONS：发现对可选特性的支持 

### 6.8.3 Allow首部 

## 6.9更多信息 

# 第7章 缓存 

## 7.1冗余的数据传输 

## 7.2带宽瓶颈 

## 7.3瞬间拥塞 

## 7.4距离时延 

## 7.5命中和未命中的 

### 7.5.1再验证 

get if-modified-since

- 命中 304 not modified
- 未命中  200 ok
- 已删除 404 not found

### 7.5.2命中率 

### 7.5.3字节命中率 

字节命中率表示的是缓存提供的字节在传输的所有字节中所占的比例。通过这种度量方式，可以得知节省流量的程度. 100% 的字节命中率说明每个字节都来自缓存， 没有流量流到因特网上去。

### 7.5.4区分命中和未命中的情况 

响应中的 Date 首部 如果比当前时间要早得多, 通常认为来自缓存

age 首部

## 7.6缓存的拓扑结构 

### 7.6.1私有缓存 

### 7.6.2公有代理缓存 

代理缓存

### 7.6.3代理缓存的层次结构 

### 7.6.4网状缓存、内容路由以及对等缓存 

## 7.7缓存的处理步骤 

(1) 接收——缓存从网络中读取抵达的请求报文。

(2) 解析——缓存对报文进行解析，提取出 URL 和各种首部。 

(3) 查询—缓存查看是否有本地副本可用，如果没有，就获取一份副本（并将其保 存在本地）。

(4)新鲜度检测——缓存查看已缓存副本是否足够新鲜，如果不是，就询问服务器是 否有任何更新。 

(5)创建响应——缓存会用新的首部和已缓存的主体来构建一条响应报文。 

(6) 发送——缓存通过网络将响应发回给客户端。 

(7)日志——缓存可选地创建一个日志文件条目来描述这个事务。

### 7.7.1第一步——接收 

### 7.7.2第二步——解析 

### 7.7.3第三步——查找 

### 7.7.4第四步——新鲜度检测 

freshness limit

### 7.7.5第五步——创建响应 

### 7.7.6第六步——发送 

### 7.7.7第七步——日志 

### 7.7.8缓存处理流程图 

## 7.8保持副本的新鲜 

![截屏2022-12-14 00.10.58](https://tva1.sinaimg.cn/large/008vxvgGly1h96wfu393oj30wk0j40ug.jpg)

### 7.8.1文档过期 

cache-control: max-age

expires

### 7.8.2过期日期和使用期 

### 7.8.3服务器再验证 

已缓存文档过期意味着到进行核对的时间了, 这种情况叫服务器再验证

### 7.8.4用条件方法进行再验证 

if-modified-since

if-none-match

### 7.8.5 If-Modified-Since：Date再验证 

IMS 请求

### 7.8.6 If-None-Match：实体标签再验证 

版本号

### 7.8.7强弱验证器 

ETag: W/"v2.6"

If-None-Match: W/"v2.6"

### 7.8.8什么时候应该使用实体标签和最近修改日期 

## 7.9控制缓存的能力 

### 7.9.1 no-Store与no-Cache响应首部 

no-store 不存储在代理缓存中

no-cache 在验证前不提供缓存

### 7.9.2 max-age响应首部 

单位: 秒

### 7.9.3 Expires响应首部 

内容: 过期的日期

### 7.9.4 must-revalidate响应首部 

Cache-Control: must-revalidate响应首部告诉缓存，在事先没有跟原始服务 器进行再验证的情况下，不能提供这个对象的陈旧副本
缓存仍然可以随意提供新 鮮的副本。如果在缓存进行 must -revalidate 新鲜度检查时，原始服务器不可 用，缓存就必须返回一条 504 Gateway Timeout 错误。

### 7.9.5试探性过期 

LM-factor

![截屏2022-12-14 00.40.40](https://tva1.sinaimg.cn/large/008vxvgGly1h96wfnrz8dj30xo08awfd.jpg)

### 7.9.6客户端的新鲜度限制 

### 7.9.7注意事项 

## 7.10设置缓存控制 

### 7.10.1控制Apache的HTTP首部 

### 7.10.2通过HTTP-EQUIv控制HTML缓存 

## 7.11详细算法 

### 7.11.1使用期和新鲜生存期 

### 7.11.2使用期的计算 

使用期就是服务器发布响应(或服务器对其进行了再验证)之后进行的总时间

### 7.11.3完整的使用期计算算法 

### 7.11.4新鲜生存期计算 

### 7.11.5完整的服务器——新鲜度算法 

## 7.12缓存和广告 

### 7.12.1发布广告者的两难处境 

缓存会向原始服务器隐藏实际的访问次数

### 7.12.2发布者的响应 

一种方法是配置缓存, 使其每次访问都要与原始服务器再验证

### 7.12.3日志迁移 

迁移命中日志

### 7.12.4命中计数和使用限制 

Meter 首部

## 7.13更多信息 

# 第8章 集成点：网关、隧道及中继 

## 8.1网关 

抽象出了一种能够到达资源的方法

## 8.2协议网关 

协议转换

### 8.2.1 HTTP/* 服务器端Web网关 

### 8.2.2 HTTP/HTTPS：服务器端安全网关 

### 8.2.3 HTTPS/HTTP客户端安全加速器网关 

## 8.3资源网关 

### 8.3.1CGI 

快速 cgi

### 8.3.2服务器扩展API 

## 8.4应用程序接口和Web服务 

## 8.5隧道 

### 8.5.1用CONNECT建立HTTP隧道 

CONNECT 方法请求隧道网关创建一条到达任意目的服务器和端口的 TCP 连接，并 对客户端和服务器之间的后继数据进行盲转发。

### 8.5.2数据隧道、定时及连接管理 

### 8.5.3 SSL隧道 

### 8.5.4 SSL隧道与HTTP/HTTPS网关的对比 

### 8.5.5隧道认证 

### 8.5.6隧道的安全性考虑 

## 8.6中继 

relay

## 8.7更多信息 

# 第9章Web机器人 

## 9.1爬虫及爬行方式 

### 9.1.1从哪儿开始：根集 

### 9.1.2链接的提取以及相对链接的标准化 

### 9.1.3避免环路的出现 

### 9.1.4循环与复制 

### 9.1.5面包屑留下的痕迹 

存在位数组, 检查点, 树和散列表

### 9.1.6别名与机器人环路 

### 9.1.7规范化URL 

### 9.1.8文件系统连接环路 

### 9.1.9动态虚拟Web空间 

### 9.1.10避免循环和重复 

## 9.2机器人的HTTP 

### 9.2.1识别请求首部 

### 9.2.2虚拟主机 

### 9.2.3条件请求 

### 9.2.4对响应的处理 

### 9.2.5 User-Agent导向 

## 9.3行为不当的机器人 

## 9.4拒绝机器人访问 

robots.txt

### 9.4.1拒绝机器人访问标准 

#### 9.4.2 Web站点和robots.txt文件 

#### 9.4.3 robots.txt文件的格式 

#### 9.4.4其他有关robots.txt的知识 

#### 9.4.5缓存和robots.txt的过期 

### 9.4.6拒绝机器人访问的Perl代码 

### 9.4.7 HTML的robot-control元标签 

## 9.5机器人的规范 

## 9.6搜索引擎 

### 9.6.1大格局 

### 9.6.2现代搜索引擎结构 

### 9.6.3全文索引 

### 9.6.4发布查询请求 

### 9.6.5对结果进行排序，并提供查询结果 

### 9.6.6欺诈 

## 9.7更多信息 

# 第10章HTTP-NG 

## 10.1 HTTP发展中存在的问题 

## 10.2 HTTP-NG的活动 

## 10.3模块化及功能增强 

## 10.4分布式对象 

## 10.5第一层——报文传输 

## 10.6第二层——远程调用 

## 10.7第三层——Web应用 

## 10.8 WebMUX 

## 10.9二进制连接协议 

## 10.10当前的状态 

## 10.11更多信息 

# 第11章 客户端识别与cookie机制 

## 11.1个性化接触 

## 11.2 HTTP首部 

## 11.3客户端IP地址 

## 11.4用户登录

authorization 首部 

## 11.5胖URL 

fat URL

对普通 url进行扩展

## 11.6 cookie 

### 11.6.1 cookie的类型 

会话 cookie , 持久 cookie

### 11.6.2 cookie是如何工作的 

服务器: set-cookie

客户端: cookie

### 11.6.3 cookie罐：客户端的状态 

```
# Netscape HTTP Cookie File
# http://www.netscape.com/newsref/sta/cookie_epec.html 
# This is a generated file! Do not edit. 
# 
# domain                 allh  path secure expires name value

www.fedex.com            FALSE /    FALSE 1136109676 cc    /us/ 
.bankofamericaonline.com TRUE  /    FALSE 1009789256 Btate CA
cnn.com                  TRUE  /    FALSE 1035069235 SelEdition www
secure.eepulse.net       FALSE /eePulse FALSE 1007162968 cid %FE%FF%002 
www.reformamt.org        TRUE  /forum FALSE 1033761379 LastVisit 1003520952 
www.reformamt.org        TRUE  /forum FALSE 1033761379 UserName Guest
```



### 11.6.4不同站点使用不同的cookie 

浏览器只向服务器发送服务器产生的那些 cookie

### 11.6.5 cookie成分 

### 11.6.6 cookies版本0（Netscape 

### 11.6.7 cookies版本1（RFC 2965） 

### 11.6.8 cookie与会话跟踪 

### 11.6.9 cookie与缓存 

### 11.6.10 cookie、安全性和隐私 

## 11.7更多信息 

# 第12章 基本认证机制 

## 12.1认证 

### 12.1.1 HTTP的质询／响应认证框架 

401 unauthorized

### 12.1.2认证协议与首部 

### 12.1.3安全域 

## 12.2基本认证 

### 12.2.1基本认证实例 

### 12.2.2 Base-64用户名／密码编码 

### 12.2.3代理认证 

## 12.3基本认证的安全缺陷 

基本认证会将用户名和密码以一种很容易解码的形式表示, 实际上就是以明码传输的

即使加密, 也可以被拦截从而不断发送请求

## 12.4更多信息 

# 第13章 摘要认证 

## 13.1摘要认证的改进 

### 13.1.1用摘要保护密码 

不发送密码, 而是发送指纹或者密码的摘要

### 13.1.2单向摘要 

MD5->128 位

### 13.1.3用随机数防止重放攻击 

随机数 nonce

### 13.1.4摘要认证的握手机制 

## 13.2摘要的计算 

### 13.2.1摘要算法的输入数据 

### 13.2.2算法H（d和KD（s，d） 

### 13.2.3与安全性相关的数据（A1） 

### 13.2.4与报文有关的数据（A2） 

### 13.2.5摘要算法总述 

### 13.2.6摘要认证会话 

### 13.2.7预授权 

成功时发送下一个随机数

### 13.2.8随机数的选择 

### 13.2.9对称认证 

## 13.3增强保护质量 

### 13.3.1报文完整性保护 

### 13.3.2摘要认证首部 

## 13.4应该考虑的实际问题 

### 13.4.1多重质询 

### 13.4.2差错处理 

### 13.4.3保护空间 

### 13.4.4重写URI 

### 13.4.5缓存 

## 13.5安全性考虑 

### 13.5.1首部篡改 

### 13.5.2重放攻击 

### 13.5.3多重认证机制 

### 13.5.4词典攻击 

### 13.5.5恶意代理攻击和中间人攻击 

### 13.5.6选择明文攻击 

使用摘要认证的客户端会用服务器提供的随机数来生成响应。但如果中间有一个被 入侵的或恶意的代理在拦截流景（或者有个恶意的原始服务器），就可以很容易地为 客户端的响应计算提供随机数。使用已知密钥来计算响应可以简化响应的密码分析 过程。这种方式被称为选择明文攻击 （chosen plaintext attack)。选择明文攻击有以 下几种变体形式。

### 13.5.7存储密码 

## 13.6更多信息 

# 第14章 安全HTTP 

## 14.1保护HTTP的安全 

## 14.2数字加密 

### 14.2.1密码编制的机制与技巧 

### 14.2.2密码 

### 14.2.3密码机 

### 14.2.4使用了密钥的密码 

这些密码参数被称为秘钥(key)

### 14.2.5数字密码 

## 14.3对称密钥加密技术 

e=d=k

### 14.3.1密钥长度与枚举攻击 

### 14.3.2建立共享密钥 

## 14.4公开密钥加密技术 

### 14.4.1RSA 

### 14.4.2混合加密系统和会话密钥 

## 14.5数字签名 

签名是(用私钥)加了密的校验和

过程:

- 将报文变为定长的摘要
- 对摘要进行私钥加密
- 将签名附在报文末尾一并发出

## 14.6数字证书 certs

### 14.6.1证书的主要内容 

- 对象的名称
- 过期时间
- 证书发布者
- 来自发布证书者的数字签名
- 对象的公开密钥

#### 14.6.2 X.509 v3证书 

### 14.6.3用证书对服务器进行认证 

## 14.7 HTTPS——细节介绍 

### 14.7.1 HTTPS概述 

### 14.7.2 HTTPS方案 

port: 443

ssl 是一个二进制协议

### 14.7.3建立安全传输 

### 14.7.4 SSL握手 

### 14.7.5服务器证书 

### 14.7.6站点证书的有效性 

CA

核对签名

验证证书中的域名和对话的服务器域名是否匹配

### 14.7.7虚拟主机与证书 

## 14.8 HTTPS客户端实例 

### 14.8.1 OpenSSL 

### 14.8.2简单的HTTPS客户端 

### 14.8.3执行OpenSSL客户端 

## 14.9通过代理以隧道形式传输安全流量 

代理是防火墙路由器唯一允许进行 http 流量交换的设备

## 14.10更多信息 

### 14.10.1 HTTP安全性 

### 14.10.2 SSL与TLS 

### 14.10.3公开密钥基础设施 

### 14.10.4数字密码 

# 第15章 实体和编码 

## 15.1报文是箱子，实体是货物 

## 15.2 Content-Length：实体的大小 

### 15.2.1检测截尾 

### 15.2.2错误的Content-Length 

### 15.2.3 Content-Length与持久连接 

### 15.2.4内容编码 

### 15.2.5确定实体主体长度的规则 

## 15.3实体摘要 

content-MD5

## 15.4媒体类型和字符集 

content-type

### 15.4.1文本的字符编码 

charset

### 15.4.2多部分媒体类型 

### 15.4.3多部分表格提交 

### 15.4.4多部分范围响应 

## 15.5内容编码 

这种编码是在发送方应用到内容之上的, 编好码的数据就放在实体主题中, 像往常一样发送给接收方

### 15.5.1内容编码过程 

### 15.5.2内容编码类型 

content-encoding

### 15.5.3 Accept-Encoding首部 

## 15.6传输编码和分块编码 

使用传输编码是为了改变报文中的数据在网络上传输的方式

经过内容编码的报文, 知识对报文的实体进行编码, 而传输编码作用在整个报文上, 报文自身的结构发生了变化

### 15.6.1可靠传输 

### 15.6.2 Transfer-Encoding首部 

### 15.6.3分块编码 

分块编码把报文分割为若干个大小已知的块。块之间是紧挨着发送的，这样就不需要在发送之前知道整个报文的大小了。

只需要允许服务器把主体逐块发送, 说明每块的大小就可以了

(服务器可以以一个大小为 0 的块作为主体结束的标志)

![截屏2022-12-15 02.19.14](https://tva1.sinaimg.cn/large/008vxvgGly1h96wfa26h6j30zu0pudiy.jpg)

### 15.6.4内容编码与传输编码的结合 

### 15.6.5传输编码的规则 

## 15.7随时间变化的实例 

## 15.8验证码和新鲜度 

### 15.8.1新鲜度 

### 15.8.2有条件的请求与验证码 

## 15.9范围请求 

允许客户端实际上之请求文档的一部分, 或者说某个范围

range 首部

## 15.10差异编码 

delta-base

## 15.11更多信息 

# 第16章 国际化 

## 16.1 HTTP对国际性内容的支持 

## 16.2字符集与HTTP 

### 16.2.1字符集是把字符转换为二进制码的编码 

### 16.2.2字符集和编码如何工作 

### 16.2.3字符集不对，字符就不对 

### 16.2.4标准化的MIME charset值 

- us-ascii 8 位最高位不用, 128 个字符
- iso-8859-1 8 位, 低 7 位和 ascii 一样, 高位支持西欧字符, 又叫 latin1, 是 html 默认字符集

### 16.2.5 Content-Type首部和Charset首部以及META标志 

### 16.2.6 Accept-Charset首部 

## 16.3多语言字符编码入门 

### 16.3.1字符集术语 

### 16.3.2字符集的命名很糟糕 

### 16.3.3字符 

### 16.3.4字形、连笔以及表示形式 

### 16.3.5编码后的字符集 

### 16.3.6字符编码方案 

- utf-8: 无模态变宽, 第一字节的高位表示编码后字符所用的字节数, 和 ascii 兼容
  ![截屏2022-12-15 02.29.38](https://tva1.sinaimg.cn/large/008vxvgGly1h96wf56vqoj30x60e4mz3.jpg)

## 16.4语言标记与HTTP 

### 16.4.1 Content-Language首部 

### 16.4.2 Accept-Language首部 

### 16.4.3语言标记的类型 

### 16.4.4子标记 

### 16.4.5大小写 

不区分大小写

### 16.4.6 IANA语言标记注册 

sgn-US-MA

三个子标记

### 16.4.7第一个子标记——名字空间 

- zh chi/zho
- en eng

### 16.4.8第二个子标记——名字空间 

- 中国 CN
- 英国 GB
- 美国 US

### 16.4.9其余子标记——名字空间 

### 16.4.10配置和语言有关的首选项 

### 16.4.11语言标记参考表 

## 16.5国际化的URI 

### 16.5.1全球性的可转抄能力与有意义的字符的较量 

### 16.5.2 URI字符集合 

![截屏2022-12-15 02.31.51](https://tva1.sinaimg.cn/large/008vxvgGly1h96wefvu2aj30x007st9e.jpg)

### 16.5.3转义和反转义 

%FF 两个十六进制表示 ascii

### 16.5.4转义国际化字符 

### 16.5.5 URI中的模态切换 

## 16.6其他需要考虑的地方 

### 16.6.1首部和不合规范的数据 

http 首部必须使用 ascii

且大小写不敏感

### 16.6.2日期 

### 16.6.3域名 

## 16.7更多信息 

### 16.7.1附录 

### 16.7.2互联网的国际化 

### 16.7.3国际标准 

# 第17章 内容协商与转码 

## 17.1内容协商技术 

## 17.2客户端驱动的协商 

## 17.3服务器驱动的协商 

### 17.3.1内容协商首部集 

### 17.3.2内容协商首部中的质量值 

q 从 0.0 到 1.0 , 1.0 优先级最高

### 17.3.3随其他首部集而变化 

### 17.3.4 Apache中的内容协商 

### 17.3.5服务器端扩展 

## 17.4透明协商 

### 17.4.1进行缓存与备用候选 

### 17.4.2 Vary首部 

## 17.5转码 

服务器可以把现存的文档转换成某种客户端可用的文档

### 17.5.1格式转换 

### 17.5.2信息综合 

### 17.5.3内容注入 

### 17.5.4转码与静态预生成的对比 

## 17.6下一步计划 

## 17.7更多信息 

# 第18章Web主机托管 

## 18.1主机托管服务 

## 18.2虚拟主机托管 

### 18.2.1虚拟服务器请求缺乏主机信息 

### 18.2.2设法让虚拟主机托管正常工作 

#### 18.2.3 HTTP/ 1.1的Host首部 

## 18.3使网站更可靠 

### 18.3.1镜像的服务器集群 

### 18.3.2内容分发网络 

### 18.3.3 CDN中的反向代理缓存 

### 18.3.4 CDN中的代理缓存 

## 18.4让网站更快 

## 18.5更多信息 

# 第19章 发布系统 

## 19.1 FrontPage为支持发布而做的服务器扩展 

### 19.1.1 FrontPage服务器扩展 

### 19.1.2 FrontPage术语表 

### 19.1.3 FrontPage的RPC协议 

### 19.1.4 FrontPage的安全模型 

## 19.2 WebDAV与协作写作 

### 19.2.1 WebDAV的方法 

### 19.2.2 WebDAV与XML 

### 19.2.3 WebDAV首部集 

### 19.2.4 WebDAV的锁定与防止覆写 

### 19.2.5 LOCK方法 

### 19.2.6 UNLOCK方法 

### 19.2.7属性和元数据 

### 19.2.8 PROPFIND方法 

### 19.2.9 PROPPATCH方法 

### 19.2.10集合与名字空间管理 

### 19.2.11 MKCOL方法 

### 19.2.12 DELETE方法 

### 19.2.13 COPY与MOVE方法 

#### 19.2.14增强的HTTP/1.1方法 

### 19.2.15 WebDAV中的版本管理 

### 19.2.16 WebDAV的未来发展 

## 19.3更多信息 

# 第20章 重定向与负载均衡 

## 20.1为什么要重定向 

## 20.2重定向到何地 

## 20.3重定向协议概览 

## 20.4通用的重定向方法 

### 20.4.1 HTTP重定向 

302 redirect

优点: 重定向服务器知道客户端的 ip

缺点: 

- 原始服务器需要处理大量重定向请求
- 增加用户时延, 因为要往返两次
- 重定向服务器瘫痪站点就会瘫痪

### 20.4.2 DNS重定向 

将几个 ip 关联到一个 domain

- dns 轮转, 通过 dns 解析轮转发送 ip 地址实现重定向和负载均衡
  但是缓存可能会讲 dns 查找得结果记住, 所以 dns 轮转通常不会平衡单个客户端的负载

### 20.4.3任播寻址 

几个地理上分散的 web 服务器拥有完全相同的 ip, 并且会通过骨干路由器的"最短路径"将客户端的请求发送给离他最近的服务器

### 20.4.4 IP MAC转发 

支持MAC 转发的第四层交换机通常会将请求转发给几个代理缓在, 并在它们之间 平衡负载。类似地，也可以将 HTTP 流量转发给备用 HTTP 服务器。

 因为 MAC 地址转发只是点对点的，所以服务器或代理只能位于离交换机**一跳远**地方。

### 20.4.5 IP地址转发 

第四层设备检测 tcp/ip 地址, 修改目的 ip 进行转发, 也叫 NAT(network address translation)

### 20.4.6网元控制协议 

NECP network element control protocol, 允许网元与服务器元素进行交互

## 20.5代理的重定向方法 

### 20.5.1显式浏览器配置 

手动

### 20.5.2代理自动配置 

PAC proxy auto config

PAC 是个 js 文件, 必须定义函数

`function FindProxyForURL(url, host)`

返回重定向的 url

### 20.5.3 Web代理自动发现协议 

WPAD  web proxy auto discovery

CURL config URL

- 使用 WPAD 找到 pac 文件的 curl
- 根据 curl 找到pac 文件
- 执行 pac 文件
- 发送 http 请求

## 20.6缓存重定向方法 

WCCP web cache communication protocol

- 启动包含了一些支持 WCCP 的路由器和缓存的网络，这些路由器和缓存之间可 以相互通信。 
- 一组路由器及其目标缓存构成一个 WCCP服务组。服务组的配置说明了要将何种流量发往何处、流量是如何发送的以及如何在服务组的缓存之间进行负载均衡。 
- 如果服务组配置为重定向 HTTP 流量，服务组中的路由器就会将 HTTP 请求发送 给服务组中的缓存。 
- HTTP 请求抵达服务组中的路由器时，路由器会（根据对请求 IP 地址的散列，或 者“掩码/值”的配对策略）选择服务组中的某个缓存为请求提供服务。
- 路由器向缓存发送请求分组，可以用缓存的 IP 地址来封装分组，也可以通过IP MAC 转发来实现。 如果缓存无法为请求提供服务，就将分组返回给路由器进行普通的转发。 服务组中的成员会互相交换心跳报文，不断验证对方的可用性。

## 20.7因特网缓存协议 

## 20.8缓存阵列路由协议 

## 20.9超文本缓存协议 

### 20.9.1 HTCP认证 

### 20.9.2设置缓存策略 

## 20.10更多信息 

# 第21章 日志记录与使用情况跟踪 

## 21.1记录内容 

## 21.2日志格式 

### 21.2.1常见日志格式 

### 21.2.2组合日志格式 

### 21.2.3网景扩展日志格式 

### 21.2.4网景扩展2日志格式 

### 21.2.5 Squid代理日志格式 

## 21.3命中率测量 

### 21.3.1概述 

### 21.3.2 Meter首部 

## 21.4关于隐私的考虑 

## 21.5更多信息 

# 第六部分 附录 

# 附录A URI方案 

# 附录BHTTP状态码 

# 附录C HTTP首部参考 

# 附录D MIME类型 

# 附录E Base-64编码 

# 附录F摘要认证 

# 附录G语言标记 

# 附录H MIME字符集注册表 

Process finished with exit code 0





































